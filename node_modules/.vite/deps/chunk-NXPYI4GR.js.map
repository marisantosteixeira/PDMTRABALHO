{
  "version": 3,
  "sources": ["../../workbox-core/_private/dontWaitFor.js", "../../idb/build/wrap-idb-value.js", "../../idb/build/index.js", "../../workbox-expiration/_version.js", "../../workbox-expiration/models/CacheTimestampsModel.js", "../../workbox-expiration/CacheExpiration.js", "../../workbox-core/registerQuotaErrorCallback.js", "../../workbox-expiration/ExpirationPlugin.js"],
  "sourcesContent": ["/*\r\n  Copyright 2019 Google LLC\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport '../_version.js';\r\n/**\r\n * A helper function that prevents a promise from being flagged as unused.\r\n *\r\n * @private\r\n **/\r\nexport function dontWaitFor(promise) {\r\n    // Effective no-op.\r\n    void promise.then(() => { });\r\n}\r\n", "const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\r\n\r\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return (idbProxyableTypes ||\r\n        (idbProxyableTypes = [\r\n            IDBDatabase,\r\n            IDBObjectStore,\r\n            IDBIndex,\r\n            IDBCursor,\r\n            IDBTransaction,\r\n        ]));\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return (cursorAdvanceMethods ||\r\n        (cursorAdvanceMethods = [\r\n            IDBCursor.prototype.advance,\r\n            IDBCursor.prototype.continue,\r\n            IDBCursor.prototype.continuePrimaryKey,\r\n        ]));\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise\r\n        .then((value) => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n        // Catching to avoid \"Uncaught Promise exceptions\"\r\n    })\r\n        .catch(() => { });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1]\r\n                    ? undefined\r\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    set(target, prop, value) {\r\n        target[prop] = value;\r\n        return true;\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction &&\r\n            (prop === 'done' || prop === 'store')) {\r\n            return true;\r\n        }\r\n        return prop in target;\r\n    },\r\n};\r\nfunction replaceTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\r\n\r\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\r\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\r\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\r\n\r\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', (event) => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\r\n        });\r\n    }\r\n    if (blocked) {\r\n        request.addEventListener('blocked', (event) => blocked(\r\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\r\n        event.oldVersion, event.newVersion, event));\r\n    }\r\n    openPromise\r\n        .then((db) => {\r\n        if (terminated)\r\n            db.addEventListener('close', () => terminated());\r\n        if (blocking) {\r\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\r\n        }\r\n    })\r\n        .catch(() => { });\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked) {\r\n        request.addEventListener('blocked', (event) => blocked(\r\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\r\n        event.oldVersion, event));\r\n    }\r\n    return wrap(request).then(() => undefined);\r\n}\r\n\r\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string')) {\r\n        return;\r\n    }\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName))) {\r\n        return;\r\n    }\r\n    const method = async function (storeName, ...args) {\r\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        // Must reject if op rejects.\r\n        // If it's a write operation, must reject if tx.done rejects.\r\n        // Must reject with op rejection first.\r\n        // Must resolve with op value.\r\n        // Must handle both promises (no unhandled rejections)\r\n        return (await Promise.all([\r\n            target[targetFuncName](...args),\r\n            isWrite && tx.done,\r\n        ]))[0];\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\nreplaceTraps((oldTraps) => ({\r\n    ...oldTraps,\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\r\n\r\nexport { deleteDB, openDB };\r\n", "\"use strict\";\r\n// @ts-ignore\r\ntry {\r\n    self['workbox:expiration:7.0.0'] && _();\r\n}\r\ncatch (e) { }\r\n", "/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { openDB, deleteDB } from 'idb';\r\nimport '../_version.js';\r\nconst DB_NAME = 'workbox-expiration';\r\nconst CACHE_OBJECT_STORE = 'cache-entries';\r\nconst normalizeURL = (unNormalizedUrl) => {\r\n    const url = new URL(unNormalizedUrl, location.href);\r\n    url.hash = '';\r\n    return url.href;\r\n};\r\n/**\r\n * Returns the timestamp model.\r\n *\r\n * @private\r\n */\r\nclass CacheTimestampsModel {\r\n    /**\r\n     *\r\n     * @param {string} cacheName\r\n     *\r\n     * @private\r\n     */\r\n    constructor(cacheName) {\r\n        this._db = null;\r\n        this._cacheName = cacheName;\r\n    }\r\n    /**\r\n     * Performs an upgrade of indexedDB.\r\n     *\r\n     * @param {IDBPDatabase<CacheDbSchema>} db\r\n     *\r\n     * @private\r\n     */\r\n    _upgradeDb(db) {\r\n        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\r\n        // have to use the `id` keyPath here and create our own values (a\r\n        // concatenation of `url + cacheName`) instead of simply using\r\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\r\n        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, { keyPath: 'id' });\r\n        // TODO(philipwalton): once we don't have to support EdgeHTML, we can\r\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\r\n        // instead of doing both these indexes.\r\n        objStore.createIndex('cacheName', 'cacheName', { unique: false });\r\n        objStore.createIndex('timestamp', 'timestamp', { unique: false });\r\n    }\r\n    /**\r\n     * Performs an upgrade of indexedDB and deletes deprecated DBs.\r\n     *\r\n     * @param {IDBPDatabase<CacheDbSchema>} db\r\n     *\r\n     * @private\r\n     */\r\n    _upgradeDbAndDeleteOldDbs(db) {\r\n        this._upgradeDb(db);\r\n        if (this._cacheName) {\r\n            void deleteDB(this._cacheName);\r\n        }\r\n    }\r\n    /**\r\n     * @param {string} url\r\n     * @param {number} timestamp\r\n     *\r\n     * @private\r\n     */\r\n    async setTimestamp(url, timestamp) {\r\n        url = normalizeURL(url);\r\n        const entry = {\r\n            url,\r\n            timestamp,\r\n            cacheName: this._cacheName,\r\n            // Creating an ID from the URL and cache name won't be necessary once\r\n            // Edge switches to Chromium and all browsers we support work with\r\n            // array keyPaths.\r\n            id: this._getId(url),\r\n        };\r\n        const db = await this.getDb();\r\n        const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {\r\n            durability: 'relaxed',\r\n        });\r\n        await tx.store.put(entry);\r\n        await tx.done;\r\n    }\r\n    /**\r\n     * Returns the timestamp stored for a given URL.\r\n     *\r\n     * @param {string} url\r\n     * @return {number | undefined}\r\n     *\r\n     * @private\r\n     */\r\n    async getTimestamp(url) {\r\n        const db = await this.getDb();\r\n        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\r\n        return entry === null || entry === void 0 ? void 0 : entry.timestamp;\r\n    }\r\n    /**\r\n     * Iterates through all the entries in the object store (from newest to\r\n     * oldest) and removes entries once either `maxCount` is reached or the\r\n     * entry's timestamp is less than `minTimestamp`.\r\n     *\r\n     * @param {number} minTimestamp\r\n     * @param {number} maxCount\r\n     * @return {Array<string>}\r\n     *\r\n     * @private\r\n     */\r\n    async expireEntries(minTimestamp, maxCount) {\r\n        const db = await this.getDb();\r\n        let cursor = await db\r\n            .transaction(CACHE_OBJECT_STORE)\r\n            .store.index('timestamp')\r\n            .openCursor(null, 'prev');\r\n        const entriesToDelete = [];\r\n        let entriesNotDeletedCount = 0;\r\n        while (cursor) {\r\n            const result = cursor.value;\r\n            // TODO(philipwalton): once we can use a multi-key index, we\r\n            // won't have to check `cacheName` here.\r\n            if (result.cacheName === this._cacheName) {\r\n                // Delete an entry if it's older than the max age or\r\n                // if we already have the max number allowed.\r\n                if ((minTimestamp && result.timestamp < minTimestamp) ||\r\n                    (maxCount && entriesNotDeletedCount >= maxCount)) {\r\n                    // TODO(philipwalton): we should be able to delete the\r\n                    // entry right here, but doing so causes an iteration\r\n                    // bug in Safari stable (fixed in TP). Instead we can\r\n                    // store the keys of the entries to delete, and then\r\n                    // delete the separate transactions.\r\n                    // https://github.com/GoogleChrome/workbox/issues/1978\r\n                    // cursor.delete();\r\n                    // We only need to return the URL, not the whole entry.\r\n                    entriesToDelete.push(cursor.value);\r\n                }\r\n                else {\r\n                    entriesNotDeletedCount++;\r\n                }\r\n            }\r\n            cursor = await cursor.continue();\r\n        }\r\n        // TODO(philipwalton): once the Safari bug in the following issue is fixed,\r\n        // we should be able to remove this loop and do the entry deletion in the\r\n        // cursor loop above:\r\n        // https://github.com/GoogleChrome/workbox/issues/1978\r\n        const urlsDeleted = [];\r\n        for (const entry of entriesToDelete) {\r\n            await db.delete(CACHE_OBJECT_STORE, entry.id);\r\n            urlsDeleted.push(entry.url);\r\n        }\r\n        return urlsDeleted;\r\n    }\r\n    /**\r\n     * Takes a URL and returns an ID that will be unique in the object store.\r\n     *\r\n     * @param {string} url\r\n     * @return {string}\r\n     *\r\n     * @private\r\n     */\r\n    _getId(url) {\r\n        // Creating an ID from the URL and cache name won't be necessary once\r\n        // Edge switches to Chromium and all browsers we support work with\r\n        // array keyPaths.\r\n        return this._cacheName + '|' + normalizeURL(url);\r\n    }\r\n    /**\r\n     * Returns an open connection to the database.\r\n     *\r\n     * @private\r\n     */\r\n    async getDb() {\r\n        if (!this._db) {\r\n            this._db = await openDB(DB_NAME, 1, {\r\n                upgrade: this._upgradeDbAndDeleteOldDbs.bind(this),\r\n            });\r\n        }\r\n        return this._db;\r\n    }\r\n}\r\nexport { CacheTimestampsModel };\r\n", "/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\r\nimport './_version.js';\r\n/**\r\n * The `CacheExpiration` class allows you define an expiration and / or\r\n * limit on the number of responses stored in a\r\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\r\n *\r\n * @memberof workbox-expiration\r\n */\r\nclass CacheExpiration {\r\n    /**\r\n     * To construct a new CacheExpiration instance you must provide at least\r\n     * one of the `config` properties.\r\n     *\r\n     * @param {string} cacheName Name of the cache to apply restrictions to.\r\n     * @param {Object} config\r\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\r\n     * Entries used the least will be removed as the maximum is reached.\r\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\r\n     * it's treated as stale and removed.\r\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\r\n     * that will be used when calling `delete()` on the cache.\r\n     */\r\n    constructor(cacheName, config = {}) {\r\n        this._isRunning = false;\r\n        this._rerunRequested = false;\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isType(cacheName, 'string', {\r\n                moduleName: 'workbox-expiration',\r\n                className: 'CacheExpiration',\r\n                funcName: 'constructor',\r\n                paramName: 'cacheName',\r\n            });\r\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\r\n                throw new WorkboxError('max-entries-or-age-required', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'CacheExpiration',\r\n                    funcName: 'constructor',\r\n                });\r\n            }\r\n            if (config.maxEntries) {\r\n                assert.isType(config.maxEntries, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'CacheExpiration',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxEntries',\r\n                });\r\n            }\r\n            if (config.maxAgeSeconds) {\r\n                assert.isType(config.maxAgeSeconds, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'CacheExpiration',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxAgeSeconds',\r\n                });\r\n            }\r\n        }\r\n        this._maxEntries = config.maxEntries;\r\n        this._maxAgeSeconds = config.maxAgeSeconds;\r\n        this._matchOptions = config.matchOptions;\r\n        this._cacheName = cacheName;\r\n        this._timestampModel = new CacheTimestampsModel(cacheName);\r\n    }\r\n    /**\r\n     * Expires entries for the given cache and given criteria.\r\n     */\r\n    async expireEntries() {\r\n        if (this._isRunning) {\r\n            this._rerunRequested = true;\r\n            return;\r\n        }\r\n        this._isRunning = true;\r\n        const minTimestamp = this._maxAgeSeconds\r\n            ? Date.now() - this._maxAgeSeconds * 1000\r\n            : 0;\r\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\r\n        // Delete URLs from the cache\r\n        const cache = await self.caches.open(this._cacheName);\r\n        for (const url of urlsExpired) {\r\n            await cache.delete(url, this._matchOptions);\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (urlsExpired.length > 0) {\r\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\r\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\r\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\r\n                    `'${this._cacheName}' cache.`);\r\n                logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\r\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\r\n                logger.groupEnd();\r\n            }\r\n            else {\r\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\r\n            }\r\n        }\r\n        this._isRunning = false;\r\n        if (this._rerunRequested) {\r\n            this._rerunRequested = false;\r\n            dontWaitFor(this.expireEntries());\r\n        }\r\n    }\r\n    /**\r\n     * Update the timestamp for the given URL. This ensures the when\r\n     * removing entries based on maximum entries, most recently used\r\n     * is accurate or when expiring, the timestamp is up-to-date.\r\n     *\r\n     * @param {string} url\r\n     */\r\n    async updateTimestamp(url) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isType(url, 'string', {\r\n                moduleName: 'workbox-expiration',\r\n                className: 'CacheExpiration',\r\n                funcName: 'updateTimestamp',\r\n                paramName: 'url',\r\n            });\r\n        }\r\n        await this._timestampModel.setTimestamp(url, Date.now());\r\n    }\r\n    /**\r\n     * Can be used to check if a URL has expired or not before it's used.\r\n     *\r\n     * This requires a look up from IndexedDB, so can be slow.\r\n     *\r\n     * Note: This method will not remove the cached entry, call\r\n     * `expireEntries()` to remove indexedDB and Cache entries.\r\n     *\r\n     * @param {string} url\r\n     * @return {boolean}\r\n     */\r\n    async isURLExpired(url) {\r\n        if (!this._maxAgeSeconds) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                throw new WorkboxError(`expired-test-without-max-age`, {\r\n                    methodName: 'isURLExpired',\r\n                    paramName: 'maxAgeSeconds',\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n        else {\r\n            const timestamp = await this._timestampModel.getTimestamp(url);\r\n            const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\r\n            return timestamp !== undefined ? timestamp < expireOlderThan : true;\r\n        }\r\n    }\r\n    /**\r\n     * Removes the IndexedDB object store used to keep track of cache expiration\r\n     * metadata.\r\n     */\r\n    async delete() {\r\n        // Make sure we don't attempt another rerun if we're called in the middle of\r\n        // a cache expiration.\r\n        this._rerunRequested = false;\r\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\r\n    }\r\n}\r\nexport { CacheExpiration };\r\n", "/*\r\n  Copyright 2019 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { logger } from './_private/logger.js';\r\nimport { assert } from './_private/assert.js';\r\nimport { quotaErrorCallbacks } from './models/quotaErrorCallbacks.js';\r\nimport './_version.js';\r\n/**\r\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\r\n * there's a quota error.\r\n *\r\n * @param {Function} callback\r\n * @memberof workbox-core\r\n */\r\n// Can't change Function type\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction registerQuotaErrorCallback(callback) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        assert.isType(callback, 'function', {\r\n            moduleName: 'workbox-core',\r\n            funcName: 'register',\r\n            paramName: 'callback',\r\n        });\r\n    }\r\n    quotaErrorCallbacks.add(callback);\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        logger.log('Registered a callback to respond to quota errors.', callback);\r\n    }\r\n}\r\nexport { registerQuotaErrorCallback };\r\n", "/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\r\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\r\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { CacheExpiration } from './CacheExpiration.js';\r\nimport './_version.js';\r\n/**\r\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\r\n * limit on the age and / or the number of cached requests.\r\n *\r\n * It can only be used with `workbox-strategy` instances that have a\r\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\r\n * In other words, it can't be used to expire entries in strategy that uses the\r\n * default runtime cache name.\r\n *\r\n * Whenever a cached response is used or updated, this plugin will look\r\n * at the associated cache and remove any old or extra responses.\r\n *\r\n * When using `maxAgeSeconds`, responses may be used *once* after expiring\r\n * because the expiration clean up will not have occurred until *after* the\r\n * cached response has been used. If the response has a \"Date\" header, then\r\n * a light weight expiration check is performed and the response will not be\r\n * used immediately.\r\n *\r\n * When using `maxEntries`, the entry least-recently requested will be removed\r\n * from the cache first.\r\n *\r\n * @memberof workbox-expiration\r\n */\r\nclass ExpirationPlugin {\r\n    /**\r\n     * @param {ExpirationPluginOptions} config\r\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\r\n     * Entries used the least will be removed as the maximum is reached.\r\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\r\n     * it's treated as stale and removed.\r\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\r\n     * that will be used when calling `delete()` on the cache.\r\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\r\n     * automatic deletion if the available storage quota has been exceeded.\r\n     */\r\n    constructor(config = {}) {\r\n        /**\r\n         * A \"lifecycle\" callback that will be triggered automatically by the\r\n         * `workbox-strategies` handlers when a `Response` is about to be returned\r\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\r\n         * the handler. It allows the `Response` to be inspected for freshness and\r\n         * prevents it from being used if the `Response`'s `Date` header value is\r\n         * older than the configured `maxAgeSeconds`.\r\n         *\r\n         * @param {Object} options\r\n         * @param {string} options.cacheName Name of the cache the response is in.\r\n         * @param {Response} options.cachedResponse The `Response` object that's been\r\n         *     read from a cache and whose freshness should be checked.\r\n         * @return {Response} Either the `cachedResponse`, if it's\r\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\r\n         *\r\n         * @private\r\n         */\r\n        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse, }) => {\r\n            if (!cachedResponse) {\r\n                return null;\r\n            }\r\n            const isFresh = this._isResponseDateFresh(cachedResponse);\r\n            // Expire entries to ensure that even if the expiration date has\r\n            // expired, it'll only be used once.\r\n            const cacheExpiration = this._getCacheExpiration(cacheName);\r\n            dontWaitFor(cacheExpiration.expireEntries());\r\n            // Update the metadata for the request URL to the current timestamp,\r\n            // but don't `await` it as we don't want to block the response.\r\n            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\r\n            if (event) {\r\n                try {\r\n                    event.waitUntil(updateTimestampDone);\r\n                }\r\n                catch (error) {\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        // The event may not be a fetch event; only log the URL if it is.\r\n                        if ('request' in event) {\r\n                            logger.warn(`Unable to ensure service worker stays alive when ` +\r\n                                `updating cache entry for ` +\r\n                                `'${getFriendlyURL(event.request.url)}'.`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return isFresh ? cachedResponse : null;\r\n        };\r\n        /**\r\n         * A \"lifecycle\" callback that will be triggered automatically by the\r\n         * `workbox-strategies` handlers when an entry is added to a cache.\r\n         *\r\n         * @param {Object} options\r\n         * @param {string} options.cacheName Name of the cache that was updated.\r\n         * @param {string} options.request The Request for the cached entry.\r\n         *\r\n         * @private\r\n         */\r\n        this.cacheDidUpdate = async ({ cacheName, request, }) => {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                assert.isType(cacheName, 'string', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'cacheDidUpdate',\r\n                    paramName: 'cacheName',\r\n                });\r\n                assert.isInstance(request, Request, {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'cacheDidUpdate',\r\n                    paramName: 'request',\r\n                });\r\n            }\r\n            const cacheExpiration = this._getCacheExpiration(cacheName);\r\n            await cacheExpiration.updateTimestamp(request.url);\r\n            await cacheExpiration.expireEntries();\r\n        };\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\r\n                throw new WorkboxError('max-entries-or-age-required', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'constructor',\r\n                });\r\n            }\r\n            if (config.maxEntries) {\r\n                assert.isType(config.maxEntries, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxEntries',\r\n                });\r\n            }\r\n            if (config.maxAgeSeconds) {\r\n                assert.isType(config.maxAgeSeconds, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxAgeSeconds',\r\n                });\r\n            }\r\n        }\r\n        this._config = config;\r\n        this._maxAgeSeconds = config.maxAgeSeconds;\r\n        this._cacheExpirations = new Map();\r\n        if (config.purgeOnQuotaError) {\r\n            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\r\n        }\r\n    }\r\n    /**\r\n     * A simple helper method to return a CacheExpiration instance for a given\r\n     * cache name.\r\n     *\r\n     * @param {string} cacheName\r\n     * @return {CacheExpiration}\r\n     *\r\n     * @private\r\n     */\r\n    _getCacheExpiration(cacheName) {\r\n        if (cacheName === cacheNames.getRuntimeName()) {\r\n            throw new WorkboxError('expire-custom-caches-only');\r\n        }\r\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\r\n        if (!cacheExpiration) {\r\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\r\n            this._cacheExpirations.set(cacheName, cacheExpiration);\r\n        }\r\n        return cacheExpiration;\r\n    }\r\n    /**\r\n     * @param {Response} cachedResponse\r\n     * @return {boolean}\r\n     *\r\n     * @private\r\n     */\r\n    _isResponseDateFresh(cachedResponse) {\r\n        if (!this._maxAgeSeconds) {\r\n            // We aren't expiring by age, so return true, it's fresh\r\n            return true;\r\n        }\r\n        // Check if the 'date' header will suffice a quick expiration check.\r\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\r\n        // discussion.\r\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\r\n        if (dateHeaderTimestamp === null) {\r\n            // Unable to parse date, so assume it's fresh.\r\n            return true;\r\n        }\r\n        // If we have a valid headerTime, then our response is fresh iff the\r\n        // headerTime plus maxAgeSeconds is greater than the current time.\r\n        const now = Date.now();\r\n        return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\r\n    }\r\n    /**\r\n     * This method will extract the data header and parse it into a useful\r\n     * value.\r\n     *\r\n     * @param {Response} cachedResponse\r\n     * @return {number|null}\r\n     *\r\n     * @private\r\n     */\r\n    _getDateHeaderTimestamp(cachedResponse) {\r\n        if (!cachedResponse.headers.has('date')) {\r\n            return null;\r\n        }\r\n        const dateHeader = cachedResponse.headers.get('date');\r\n        const parsedDate = new Date(dateHeader);\r\n        const headerTime = parsedDate.getTime();\r\n        // If the Date header was invalid for some reason, parsedDate.getTime()\r\n        // will return NaN.\r\n        if (isNaN(headerTime)) {\r\n            return null;\r\n        }\r\n        return headerTime;\r\n    }\r\n    /**\r\n     * This is a helper method that performs two operations:\r\n     *\r\n     * - Deletes *all* the underlying Cache instances associated with this plugin\r\n     * instance, by calling caches.delete() on your behalf.\r\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\r\n     * details for each Cache instance.\r\n     *\r\n     * When using cache expiration, calling this method is preferable to calling\r\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\r\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\r\n     *\r\n     * Note that if you're *not* using cache expiration for a given cache, calling\r\n     * `caches.delete()` and passing in the cache's name should be sufficient.\r\n     * There is no Workbox-specific method needed for cleanup in that case.\r\n     */\r\n    async deleteCacheAndMetadata() {\r\n        // Do this one at a time instead of all at once via `Promise.all()` to\r\n        // reduce the chance of inconsistency if a promise rejects.\r\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\r\n            await self.caches.delete(cacheName);\r\n            await cacheExpiration.delete();\r\n        }\r\n        // Reset this._cacheExpirations to its initial state.\r\n        this._cacheExpirations = new Map();\r\n    }\r\n}\r\nexport { ExpirationPlugin };\r\n"],
  "mappings": "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",
  "names": ["target"]
}
