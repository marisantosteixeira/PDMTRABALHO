{
  "version": 3,
  "sources": ["../../workbox-recipes/_version.js", "../../workbox-recipes/googleFontsCache.js", "../../workbox-recipes/warmStrategyCache.js", "../../workbox-recipes/imageCache.js", "../../workbox-recipes/staticResourceCache.js", "../../workbox-recipes/pageCache.js", "../../workbox-core/_private/waitUntil.js", "../../workbox-precaching/_version.js", "../../workbox-precaching/utils/createCacheKey.js", "../../workbox-precaching/utils/PrecacheInstallReportPlugin.js", "../../workbox-precaching/utils/PrecacheCacheKeyPlugin.js", "../../workbox-precaching/utils/printCleanupDetails.js", "../../workbox-precaching/utils/printInstallDetails.js", "../../workbox-core/_private/canConstructResponseFromBodyStream.js", "../../workbox-core/copyResponse.js", "../../workbox-precaching/PrecacheStrategy.js", "../../workbox-precaching/PrecacheController.js", "../../workbox-precaching/utils/getOrCreatePrecacheController.js", "../../workbox-precaching/matchPrecache.js", "../../workbox-recipes/offlineFallback.js"],
  "sourcesContent": ["\"use strict\";\r\n// @ts-ignore\r\ntry {\r\n    self['workbox:recipes:7.0.0'] && _();\r\n}\r\ncatch (e) { }\r\n", "/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\r\nimport { StaleWhileRevalidate } from 'workbox-strategies/StaleWhileRevalidate.js';\r\nimport { CacheFirst } from 'workbox-strategies/CacheFirst.js';\r\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\r\nimport { ExpirationPlugin } from 'workbox-expiration/ExpirationPlugin.js';\r\nimport './_version.js';\r\n/**\r\n * An implementation of the [Google fonts]{@link https://developers.google.com/web/tools/workbox/guides/common-recipes#google_fonts} caching recipe\r\n *\r\n * @memberof workbox-recipes\r\n *\r\n * @param {Object} [options]\r\n * @param {string} [options.cachePrefix] Cache prefix for caching stylesheets and webfonts. Defaults to google-fonts\r\n * @param {number} [options.maxAgeSeconds] Maximum age, in seconds, that font entries will be cached for. Defaults to 1 year\r\n * @param {number} [options.maxEntries] Maximum number of fonts that will be cached. Defaults to 30\r\n */\r\nfunction googleFontsCache(options = {}) {\r\n    const sheetCacheName = `${options.cachePrefix || 'google-fonts'}-stylesheets`;\r\n    const fontCacheName = `${options.cachePrefix || 'google-fonts'}-webfonts`;\r\n    const maxAgeSeconds = options.maxAgeSeconds || 60 * 60 * 24 * 365;\r\n    const maxEntries = options.maxEntries || 30;\r\n    // Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.\r\n    registerRoute(({ url }) => url.origin === 'https://fonts.googleapis.com', new StaleWhileRevalidate({\r\n        cacheName: sheetCacheName,\r\n    }));\r\n    // Cache the underlying font files with a cache-first strategy for 1 year.\r\n    registerRoute(({ url }) => url.origin === 'https://fonts.gstatic.com', new CacheFirst({\r\n        cacheName: fontCacheName,\r\n        plugins: [\r\n            new CacheableResponsePlugin({\r\n                statuses: [0, 200],\r\n            }),\r\n            new ExpirationPlugin({\r\n                maxAgeSeconds,\r\n                maxEntries,\r\n            }),\r\n        ],\r\n    }));\r\n}\r\nexport { googleFontsCache };\r\n", "import './_version.js';\r\n/**\r\n * @memberof workbox-recipes\r\n \r\n * @param {Object} options\r\n * @param {string[]} options.urls Paths to warm the strategy's cache with\r\n * @param {Strategy} options.strategy Strategy to use\r\n */\r\nfunction warmStrategyCache(options) {\r\n    self.addEventListener('install', (event) => {\r\n        const done = options.urls.map((path) => options.strategy.handleAll({\r\n            event,\r\n            request: new Request(path),\r\n        })[1]);\r\n        event.waitUntil(Promise.all(done));\r\n    });\r\n}\r\nexport { warmStrategyCache };\r\n", "/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { warmStrategyCache } from './warmStrategyCache';\r\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\r\nimport { CacheFirst } from 'workbox-strategies/CacheFirst.js';\r\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\r\nimport { ExpirationPlugin } from 'workbox-expiration/ExpirationPlugin.js';\r\nimport './_version.js';\r\n/**\r\n * An implementation of the [image caching recipe]{@link https://developers.google.com/web/tools/workbox/guides/common-recipes#caching_images}\r\n *\r\n * @memberof workbox-recipes\r\n *\r\n * @param {Object} [options]\r\n * @param {string} [options.cacheName] Name for cache. Defaults to images\r\n * @param {RouteMatchCallback} [options.matchCallback] Workbox callback function to call to match to. Defaults to request.destination === 'image';\r\n * @param {number} [options.maxAgeSeconds] Maximum age, in seconds, that font entries will be cached for. Defaults to 30 days\r\n * @param {number} [options.maxEntries] Maximum number of images that will be cached. Defaults to 60\r\n * @param {WorkboxPlugin[]} [options.plugins] Additional plugins to use for this recipe\r\n * @param {string[]} [options.warmCache] Paths to call to use to warm this cache\r\n */\r\nfunction imageCache(options = {}) {\r\n    const defaultMatchCallback = ({ request }) => request.destination === 'image';\r\n    const cacheName = options.cacheName || 'images';\r\n    const matchCallback = options.matchCallback || defaultMatchCallback;\r\n    const maxAgeSeconds = options.maxAgeSeconds || 30 * 24 * 60 * 60;\r\n    const maxEntries = options.maxEntries || 60;\r\n    const plugins = options.plugins || [];\r\n    plugins.push(new CacheableResponsePlugin({\r\n        statuses: [0, 200],\r\n    }));\r\n    plugins.push(new ExpirationPlugin({\r\n        maxEntries,\r\n        maxAgeSeconds,\r\n    }));\r\n    const strategy = new CacheFirst({\r\n        cacheName,\r\n        plugins,\r\n    });\r\n    registerRoute(matchCallback, strategy);\r\n    // Warms the cache\r\n    if (options.warmCache) {\r\n        warmStrategyCache({ urls: options.warmCache, strategy });\r\n    }\r\n}\r\nexport { imageCache };\r\n", "/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { warmStrategyCache } from './warmStrategyCache';\r\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\r\nimport { StaleWhileRevalidate } from 'workbox-strategies/StaleWhileRevalidate.js';\r\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\r\nimport './_version.js';\r\n/**\r\n * An implementation of the [CSS and JavaScript files recipe]{@link https://developers.google.com/web/tools/workbox/guides/common-recipes#cache_css_and_javascript_files}\r\n *\r\n * @memberof workbox-recipes\r\n *\r\n * @param {Object} [options]\r\n * @param {string} [options.cacheName] Name for cache. Defaults to static-resources\r\n * @param {RouteMatchCallback} [options.matchCallback] Workbox callback function to call to match to. Defaults to request.destination === 'style' || request.destination === 'script' || request.destination === 'worker';\r\n * @param {WorkboxPlugin[]} [options.plugins] Additional plugins to use for this recipe\r\n * @param {string[]} [options.warmCache] Paths to call to use to warm this cache\r\n */\r\nfunction staticResourceCache(options = {}) {\r\n    const defaultMatchCallback = ({ request }) => request.destination === 'style' ||\r\n        request.destination === 'script' ||\r\n        request.destination === 'worker';\r\n    const cacheName = options.cacheName || 'static-resources';\r\n    const matchCallback = options.matchCallback || defaultMatchCallback;\r\n    const plugins = options.plugins || [];\r\n    plugins.push(new CacheableResponsePlugin({\r\n        statuses: [0, 200],\r\n    }));\r\n    const strategy = new StaleWhileRevalidate({\r\n        cacheName,\r\n        plugins,\r\n    });\r\n    registerRoute(matchCallback, strategy);\r\n    // Warms the cache\r\n    if (options.warmCache) {\r\n        warmStrategyCache({ urls: options.warmCache, strategy });\r\n    }\r\n}\r\nexport { staticResourceCache };\r\n", "/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { warmStrategyCache } from './warmStrategyCache';\r\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\r\nimport { NetworkFirst } from 'workbox-strategies/NetworkFirst.js';\r\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\r\nimport './_version.js';\r\n/**\r\n * An implementation of a page caching recipe with a network timeout\r\n *\r\n * @memberof workbox-recipes\r\n *\r\n * @param {Object} [options]\r\n * @param {string} [options.cacheName] Name for cache. Defaults to pages\r\n * @param {RouteMatchCallback} [options.matchCallback] Workbox callback function to call to match to. Defaults to request.mode === 'navigate';\r\n * @param {number} [options.networkTimoutSeconds] Maximum amount of time, in seconds, to wait on the network before falling back to cache. Defaults to 3\r\n * @param {WorkboxPlugin[]} [options.plugins] Additional plugins to use for this recipe\r\n * @param {string[]} [options.warmCache] Paths to call to use to warm this cache\r\n */\r\nfunction pageCache(options = {}) {\r\n    const defaultMatchCallback = ({ request }) => request.mode === 'navigate';\r\n    const cacheName = options.cacheName || 'pages';\r\n    const matchCallback = options.matchCallback || defaultMatchCallback;\r\n    const networkTimeoutSeconds = options.networkTimeoutSeconds || 3;\r\n    const plugins = options.plugins || [];\r\n    plugins.push(new CacheableResponsePlugin({\r\n        statuses: [0, 200],\r\n    }));\r\n    const strategy = new NetworkFirst({\r\n        networkTimeoutSeconds,\r\n        cacheName,\r\n        plugins,\r\n    });\r\n    // Registers the route\r\n    registerRoute(matchCallback, strategy);\r\n    // Warms the cache\r\n    if (options.warmCache) {\r\n        warmStrategyCache({ urls: options.warmCache, strategy });\r\n    }\r\n}\r\nexport { pageCache };\r\n", "/*\r\n  Copyright 2020 Google LLC\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport '../_version.js';\r\n/**\r\n * A utility method that makes it easier to use `event.waitUntil` with\r\n * async functions and return the result.\r\n *\r\n * @param {ExtendableEvent} event\r\n * @param {Function} asyncFn\r\n * @return {Function}\r\n * @private\r\n */\r\nfunction waitUntil(event, asyncFn) {\r\n    const returnPromise = asyncFn();\r\n    event.waitUntil(returnPromise);\r\n    return returnPromise;\r\n}\r\nexport { waitUntil };\r\n", "\"use strict\";\r\n// @ts-ignore\r\ntry {\r\n    self['workbox:precaching:7.0.0'] && _();\r\n}\r\ncatch (e) { }\r\n", "/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport '../_version.js';\r\n// Name of the search parameter used to store revision info.\r\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\r\n/**\r\n * Converts a manifest entry into a versioned URL suitable for precaching.\r\n *\r\n * @param {Object|string} entry\r\n * @return {string} A URL with versioning info.\r\n *\r\n * @private\r\n * @memberof workbox-precaching\r\n */\r\nexport function createCacheKey(entry) {\r\n    if (!entry) {\r\n        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });\r\n    }\r\n    // If a precache manifest entry is a string, it's assumed to be a versioned\r\n    // URL, like '/app.abcd1234.js'. Return as-is.\r\n    if (typeof entry === 'string') {\r\n        const urlObject = new URL(entry, location.href);\r\n        return {\r\n            cacheKey: urlObject.href,\r\n            url: urlObject.href,\r\n        };\r\n    }\r\n    const { revision, url } = entry;\r\n    if (!url) {\r\n        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });\r\n    }\r\n    // If there's just a URL and no revision, then it's also assumed to be a\r\n    // versioned URL.\r\n    if (!revision) {\r\n        const urlObject = new URL(url, location.href);\r\n        return {\r\n            cacheKey: urlObject.href,\r\n            url: urlObject.href,\r\n        };\r\n    }\r\n    // Otherwise, construct a properly versioned URL using the custom Workbox\r\n    // search parameter along with the revision info.\r\n    const cacheKeyURL = new URL(url, location.href);\r\n    const originalURL = new URL(url, location.href);\r\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\r\n    return {\r\n        cacheKey: cacheKeyURL.href,\r\n        url: originalURL.href,\r\n    };\r\n}\r\n", "/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport '../_version.js';\r\n/**\r\n * A plugin, designed to be used with PrecacheController, to determine the\r\n * of assets that were updated (or not updated) during the install event.\r\n *\r\n * @private\r\n */\r\nclass PrecacheInstallReportPlugin {\r\n    constructor() {\r\n        this.updatedURLs = [];\r\n        this.notUpdatedURLs = [];\r\n        this.handlerWillStart = async ({ request, state, }) => {\r\n            // TODO: `state` should never be undefined...\r\n            if (state) {\r\n                state.originalRequest = request;\r\n            }\r\n        };\r\n        this.cachedResponseWillBeUsed = async ({ event, state, cachedResponse, }) => {\r\n            if (event.type === 'install') {\r\n                if (state &&\r\n                    state.originalRequest &&\r\n                    state.originalRequest instanceof Request) {\r\n                    // TODO: `state` should never be undefined...\r\n                    const url = state.originalRequest.url;\r\n                    if (cachedResponse) {\r\n                        this.notUpdatedURLs.push(url);\r\n                    }\r\n                    else {\r\n                        this.updatedURLs.push(url);\r\n                    }\r\n                }\r\n            }\r\n            return cachedResponse;\r\n        };\r\n    }\r\n}\r\nexport { PrecacheInstallReportPlugin };\r\n", "/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport '../_version.js';\r\n/**\r\n * A plugin, designed to be used with PrecacheController, to translate URLs into\r\n * the corresponding cache key, based on the current revision info.\r\n *\r\n * @private\r\n */\r\nclass PrecacheCacheKeyPlugin {\r\n    constructor({ precacheController }) {\r\n        this.cacheKeyWillBeUsed = async ({ request, params, }) => {\r\n            // Params is type any, can't change right now.\r\n            /* eslint-disable */\r\n            const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) ||\r\n                this._precacheController.getCacheKeyForURL(request.url);\r\n            /* eslint-enable */\r\n            return cacheKey\r\n                ? new Request(cacheKey, { headers: request.headers })\r\n                : request;\r\n        };\r\n        this._precacheController = precacheController;\r\n    }\r\n}\r\nexport { PrecacheCacheKeyPlugin };\r\n", "/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport '../_version.js';\r\n/**\r\n * @param {string} groupTitle\r\n * @param {Array<string>} deletedURLs\r\n *\r\n * @private\r\n */\r\nconst logGroup = (groupTitle, deletedURLs) => {\r\n    logger.groupCollapsed(groupTitle);\r\n    for (const url of deletedURLs) {\r\n        logger.log(url);\r\n    }\r\n    logger.groupEnd();\r\n};\r\n/**\r\n * @param {Array<string>} deletedURLs\r\n *\r\n * @private\r\n * @memberof workbox-precaching\r\n */\r\nexport function printCleanupDetails(deletedURLs) {\r\n    const deletionCount = deletedURLs.length;\r\n    if (deletionCount > 0) {\r\n        logger.groupCollapsed(`During precaching cleanup, ` +\r\n            `${deletionCount} cached ` +\r\n            `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\r\n        logGroup('Deleted Cache Requests', deletedURLs);\r\n        logger.groupEnd();\r\n    }\r\n}\r\n", "/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport '../_version.js';\r\n/**\r\n * @param {string} groupTitle\r\n * @param {Array<string>} urls\r\n *\r\n * @private\r\n */\r\nfunction _nestedGroup(groupTitle, urls) {\r\n    if (urls.length === 0) {\r\n        return;\r\n    }\r\n    logger.groupCollapsed(groupTitle);\r\n    for (const url of urls) {\r\n        logger.log(url);\r\n    }\r\n    logger.groupEnd();\r\n}\r\n/**\r\n * @param {Array<string>} urlsToPrecache\r\n * @param {Array<string>} urlsAlreadyPrecached\r\n *\r\n * @private\r\n * @memberof workbox-precaching\r\n */\r\nexport function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\r\n    const precachedCount = urlsToPrecache.length;\r\n    const alreadyPrecachedCount = urlsAlreadyPrecached.length;\r\n    if (precachedCount || alreadyPrecachedCount) {\r\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\r\n        if (alreadyPrecachedCount > 0) {\r\n            message +=\r\n                ` ${alreadyPrecachedCount} ` +\r\n                    `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\r\n        }\r\n        logger.groupCollapsed(message);\r\n        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\r\n        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\r\n        logger.groupEnd();\r\n    }\r\n}\r\n", "/*\r\n  Copyright 2019 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport '../_version.js';\r\nlet supportStatus;\r\n/**\r\n * A utility function that determines whether the current browser supports\r\n * constructing a new `Response` from a `response.body` stream.\r\n *\r\n * @return {boolean} `true`, if the current browser can successfully\r\n *     construct a `Response` from a `response.body` stream, `false` otherwise.\r\n *\r\n * @private\r\n */\r\nfunction canConstructResponseFromBodyStream() {\r\n    if (supportStatus === undefined) {\r\n        const testResponse = new Response('');\r\n        if ('body' in testResponse) {\r\n            try {\r\n                new Response(testResponse.body);\r\n                supportStatus = true;\r\n            }\r\n            catch (error) {\r\n                supportStatus = false;\r\n            }\r\n        }\r\n        supportStatus = false;\r\n    }\r\n    return supportStatus;\r\n}\r\nexport { canConstructResponseFromBodyStream };\r\n", "/*\r\n  Copyright 2019 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { canConstructResponseFromBodyStream } from './_private/canConstructResponseFromBodyStream.js';\r\nimport { WorkboxError } from './_private/WorkboxError.js';\r\nimport './_version.js';\r\n/**\r\n * Allows developers to copy a response and modify its `headers`, `status`,\r\n * or `statusText` values (the values settable via a\r\n * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\r\n * object in the constructor).\r\n * To modify these values, pass a function as the second argument. That\r\n * function will be invoked with a single object with the response properties\r\n * `{headers, status, statusText}`. The return value of this function will\r\n * be used as the `ResponseInit` for the new `Response`. To change the values\r\n * either modify the passed parameter(s) and return it, or return a totally\r\n * new object.\r\n *\r\n * This method is intentionally limited to same-origin responses, regardless of\r\n * whether CORS was used or not.\r\n *\r\n * @param {Response} response\r\n * @param {Function} modifier\r\n * @memberof workbox-core\r\n */\r\nasync function copyResponse(response, modifier) {\r\n    let origin = null;\r\n    // If response.url isn't set, assume it's cross-origin and keep origin null.\r\n    if (response.url) {\r\n        const responseURL = new URL(response.url);\r\n        origin = responseURL.origin;\r\n    }\r\n    if (origin !== self.location.origin) {\r\n        throw new WorkboxError('cross-origin-copy-response', { origin });\r\n    }\r\n    const clonedResponse = response.clone();\r\n    // Create a fresh `ResponseInit` object by cloning the headers.\r\n    const responseInit = {\r\n        headers: new Headers(clonedResponse.headers),\r\n        status: clonedResponse.status,\r\n        statusText: clonedResponse.statusText,\r\n    };\r\n    // Apply any user modifications.\r\n    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\r\n    // Create the new response from the body stream and `ResponseInit`\r\n    // modifications. Note: not all browsers support the Response.body stream,\r\n    // so fall back to reading the entire body into memory as a blob.\r\n    const body = canConstructResponseFromBodyStream()\r\n        ? clonedResponse.body\r\n        : await clonedResponse.blob();\r\n    return new Response(body, modifiedResponseInit);\r\n}\r\nexport { copyResponse };\r\n", "/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { copyResponse } from 'workbox-core/copyResponse.js';\r\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\r\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { Strategy } from 'workbox-strategies/Strategy.js';\r\nimport './_version.js';\r\n/**\r\n * A {@link workbox-strategies.Strategy} implementation\r\n * specifically designed to work with\r\n * {@link workbox-precaching.PrecacheController}\r\n * to both cache and fetch precached assets.\r\n *\r\n * Note: an instance of this class is created automatically when creating a\r\n * `PrecacheController`; it's generally not necessary to create this yourself.\r\n *\r\n * @extends workbox-strategies.Strategy\r\n * @memberof workbox-precaching\r\n */\r\nclass PrecacheStrategy extends Strategy {\r\n    /**\r\n     *\r\n     * @param {Object} [options]\r\n     * @param {string} [options.cacheName] Cache name to store and retrieve\r\n     * requests. Defaults to the cache names provided by\r\n     * {@link workbox-core.cacheNames}.\r\n     * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\r\n     * to use in conjunction with this caching strategy.\r\n     * @param {Object} [options.fetchOptions] Values passed along to the\r\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\r\n     * of all fetch() requests made by this strategy.\r\n     * @param {Object} [options.matchOptions] The\r\n     * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\r\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\r\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\r\n     * get the response from the network if there's a precache miss.\r\n     */\r\n    constructor(options = {}) {\r\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\r\n        super(options);\r\n        this._fallbackToNetwork =\r\n            options.fallbackToNetwork === false ? false : true;\r\n        // Redirected responses cannot be used to satisfy a navigation request, so\r\n        // any redirected response must be \"copied\" rather than cloned, so the new\r\n        // response doesn't contain the `redirected` flag. See:\r\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\r\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {Request|string} request A request to run this strategy for.\r\n     * @param {workbox-strategies.StrategyHandler} handler The event that\r\n     *     triggered the request.\r\n     * @return {Promise<Response>}\r\n     */\r\n    async _handle(request, handler) {\r\n        const response = await handler.cacheMatch(request);\r\n        if (response) {\r\n            return response;\r\n        }\r\n        // If this is an `install` event for an entry that isn't already cached,\r\n        // then populate the cache.\r\n        if (handler.event && handler.event.type === 'install') {\r\n            return await this._handleInstall(request, handler);\r\n        }\r\n        // Getting here means something went wrong. An entry that should have been\r\n        // precached wasn't found in the cache.\r\n        return await this._handleFetch(request, handler);\r\n    }\r\n    async _handleFetch(request, handler) {\r\n        let response;\r\n        const params = (handler.params || {});\r\n        // Fall back to the network if we're configured to do so.\r\n        if (this._fallbackToNetwork) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logger.warn(`The precached response for ` +\r\n                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +\r\n                    `found. Falling back to the network.`);\r\n            }\r\n            const integrityInManifest = params.integrity;\r\n            const integrityInRequest = request.integrity;\r\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\r\n            // Do not add integrity if the original request is no-cors\r\n            // See https://github.com/GoogleChrome/workbox/issues/3096\r\n            response = await handler.fetch(new Request(request, {\r\n                integrity: request.mode !== 'no-cors'\r\n                    ? integrityInRequest || integrityInManifest\r\n                    : undefined,\r\n            }));\r\n            // It's only \"safe\" to repair the cache if we're using SRI to guarantee\r\n            // that the response matches the precache manifest's expectations,\r\n            // and there's either a) no integrity property in the incoming request\r\n            // or b) there is an integrity, and it matches the precache manifest.\r\n            // See https://github.com/GoogleChrome/workbox/issues/2858\r\n            // Also if the original request users no-cors we don't use integrity.\r\n            // See https://github.com/GoogleChrome/workbox/issues/3096\r\n            if (integrityInManifest &&\r\n                noIntegrityConflict &&\r\n                request.mode !== 'no-cors') {\r\n                this._useDefaultCacheabilityPluginIfNeeded();\r\n                const wasCached = await handler.cachePut(request, response.clone());\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    if (wasCached) {\r\n                        logger.log(`A response for ${getFriendlyURL(request.url)} ` +\r\n                            `was used to \"repair\" the precache.`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // This shouldn't normally happen, but there are edge cases:\r\n            // https://github.com/GoogleChrome/workbox/issues/1441\r\n            throw new WorkboxError('missing-precache-entry', {\r\n                cacheName: this.cacheName,\r\n                url: request.url,\r\n            });\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\r\n            // Workbox is going to handle the route.\r\n            // print the routing details to the console.\r\n            logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\r\n            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\r\n            logger.groupCollapsed(`View request details here.`);\r\n            logger.log(request);\r\n            logger.groupEnd();\r\n            logger.groupCollapsed(`View response details here.`);\r\n            logger.log(response);\r\n            logger.groupEnd();\r\n            logger.groupEnd();\r\n        }\r\n        return response;\r\n    }\r\n    async _handleInstall(request, handler) {\r\n        this._useDefaultCacheabilityPluginIfNeeded();\r\n        const response = await handler.fetch(request);\r\n        // Make sure we defer cachePut() until after we know the response\r\n        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\r\n        const wasCached = await handler.cachePut(request, response.clone());\r\n        if (!wasCached) {\r\n            // Throwing here will lead to the `install` handler failing, which\r\n            // we want to do if *any* of the responses aren't safe to cache.\r\n            throw new WorkboxError('bad-precaching-response', {\r\n                url: request.url,\r\n                status: response.status,\r\n            });\r\n        }\r\n        return response;\r\n    }\r\n    /**\r\n     * This method is complex, as there a number of things to account for:\r\n     *\r\n     * The `plugins` array can be set at construction, and/or it might be added to\r\n     * to at any time before the strategy is used.\r\n     *\r\n     * At the time the strategy is used (i.e. during an `install` event), there\r\n     * needs to be at least one plugin that implements `cacheWillUpdate` in the\r\n     * array, other than `copyRedirectedCacheableResponsesPlugin`.\r\n     *\r\n     * - If this method is called and there are no suitable `cacheWillUpdate`\r\n     * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\r\n     *\r\n     * - If this method is called and there is exactly one `cacheWillUpdate`, then\r\n     * we don't have to do anything (this might be a previously added\r\n     * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\r\n     *\r\n     * - If this method is called and there is more than one `cacheWillUpdate`,\r\n     * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\r\n     * we need to remove it. (This situation is unlikely, but it could happen if\r\n     * the strategy is used multiple times, the first without a `cacheWillUpdate`,\r\n     * and then later on after manually adding a custom `cacheWillUpdate`.)\r\n     *\r\n     * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\r\n     *\r\n     * @private\r\n     */\r\n    _useDefaultCacheabilityPluginIfNeeded() {\r\n        let defaultPluginIndex = null;\r\n        let cacheWillUpdatePluginCount = 0;\r\n        for (const [index, plugin] of this.plugins.entries()) {\r\n            // Ignore the copy redirected plugin when determining what to do.\r\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\r\n                continue;\r\n            }\r\n            // Save the default plugin's index, in case it needs to be removed.\r\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\r\n                defaultPluginIndex = index;\r\n            }\r\n            if (plugin.cacheWillUpdate) {\r\n                cacheWillUpdatePluginCount++;\r\n            }\r\n        }\r\n        if (cacheWillUpdatePluginCount === 0) {\r\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\r\n        }\r\n        else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\r\n            // Only remove the default plugin; multiple custom plugins are allowed.\r\n            this.plugins.splice(defaultPluginIndex, 1);\r\n        }\r\n        // Nothing needs to be done if cacheWillUpdatePluginCount is 1\r\n    }\r\n}\r\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\r\n    async cacheWillUpdate({ response }) {\r\n        if (!response || response.status >= 400) {\r\n            return null;\r\n        }\r\n        return response;\r\n    },\r\n};\r\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\r\n    async cacheWillUpdate({ response }) {\r\n        return response.redirected ? await copyResponse(response) : response;\r\n    },\r\n};\r\nexport { PrecacheStrategy };\r\n", "/*\r\n  Copyright 2019 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\r\nimport { createCacheKey } from './utils/createCacheKey.js';\r\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\r\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\r\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\r\nimport { printInstallDetails } from './utils/printInstallDetails.js';\r\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\r\nimport './_version.js';\r\n/**\r\n * Performs efficient precaching of assets.\r\n *\r\n * @memberof workbox-precaching\r\n */\r\nclass PrecacheController {\r\n    /**\r\n     * Create a new PrecacheController.\r\n     *\r\n     * @param {Object} [options]\r\n     * @param {string} [options.cacheName] The cache to use for precaching.\r\n     * @param {string} [options.plugins] Plugins to use when precaching as well\r\n     * as responding to fetch events for precached assets.\r\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\r\n     * get the response from the network if there's a precache miss.\r\n     */\r\n    constructor({ cacheName, plugins = [], fallbackToNetwork = true, } = {}) {\r\n        this._urlsToCacheKeys = new Map();\r\n        this._urlsToCacheModes = new Map();\r\n        this._cacheKeysToIntegrities = new Map();\r\n        this._strategy = new PrecacheStrategy({\r\n            cacheName: cacheNames.getPrecacheName(cacheName),\r\n            plugins: [\r\n                ...plugins,\r\n                new PrecacheCacheKeyPlugin({ precacheController: this }),\r\n            ],\r\n            fallbackToNetwork,\r\n        });\r\n        // Bind the install and activate methods to the instance.\r\n        this.install = this.install.bind(this);\r\n        this.activate = this.activate.bind(this);\r\n    }\r\n    /**\r\n     * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\r\n     * used to cache assets and respond to fetch events.\r\n     */\r\n    get strategy() {\r\n        return this._strategy;\r\n    }\r\n    /**\r\n     * Adds items to the precache list, removing any duplicates and\r\n     * stores the files in the\r\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\r\n     * worker installs.\r\n     *\r\n     * This method can be called multiple times.\r\n     *\r\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\r\n     */\r\n    precache(entries) {\r\n        this.addToCacheList(entries);\r\n        if (!this._installAndActiveListenersAdded) {\r\n            self.addEventListener('install', this.install);\r\n            self.addEventListener('activate', this.activate);\r\n            this._installAndActiveListenersAdded = true;\r\n        }\r\n    }\r\n    /**\r\n     * This method will add items to the precache list, removing duplicates\r\n     * and ensuring the information is valid.\r\n     *\r\n     * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\r\n     *     Array of entries to precache.\r\n     */\r\n    addToCacheList(entries) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isArray(entries, {\r\n                moduleName: 'workbox-precaching',\r\n                className: 'PrecacheController',\r\n                funcName: 'addToCacheList',\r\n                paramName: 'entries',\r\n            });\r\n        }\r\n        const urlsToWarnAbout = [];\r\n        for (const entry of entries) {\r\n            // See https://github.com/GoogleChrome/workbox/issues/2259\r\n            if (typeof entry === 'string') {\r\n                urlsToWarnAbout.push(entry);\r\n            }\r\n            else if (entry && entry.revision === undefined) {\r\n                urlsToWarnAbout.push(entry.url);\r\n            }\r\n            const { cacheKey, url } = createCacheKey(entry);\r\n            const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\r\n            if (this._urlsToCacheKeys.has(url) &&\r\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\r\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\r\n                    firstEntry: this._urlsToCacheKeys.get(url),\r\n                    secondEntry: cacheKey,\r\n                });\r\n            }\r\n            if (typeof entry !== 'string' && entry.integrity) {\r\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\r\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\r\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\r\n                        url,\r\n                    });\r\n                }\r\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\r\n            }\r\n            this._urlsToCacheKeys.set(url, cacheKey);\r\n            this._urlsToCacheModes.set(url, cacheMode);\r\n            if (urlsToWarnAbout.length > 0) {\r\n                const warningMessage = `Workbox is precaching URLs without revision ` +\r\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\r\n                    `Learn more at https://bit.ly/wb-precache`;\r\n                if (process.env.NODE_ENV === 'production') {\r\n                    // Use console directly to display this warning without bloating\r\n                    // bundle sizes by pulling in all of the logger codebase in prod.\r\n                    console.warn(warningMessage);\r\n                }\r\n                else {\r\n                    logger.warn(warningMessage);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Precaches new and updated assets. Call this method from the service worker\r\n     * install event.\r\n     *\r\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\r\n     * to call it yourself in your event handlers.\r\n     *\r\n     * @param {ExtendableEvent} event\r\n     * @return {Promise<workbox-precaching.InstallResult>}\r\n     */\r\n    install(event) {\r\n        // waitUntil returns Promise<any>\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n        return waitUntil(event, async () => {\r\n            const installReportPlugin = new PrecacheInstallReportPlugin();\r\n            this.strategy.plugins.push(installReportPlugin);\r\n            // Cache entries one at a time.\r\n            // See https://github.com/GoogleChrome/workbox/issues/2528\r\n            for (const [url, cacheKey] of this._urlsToCacheKeys) {\r\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\r\n                const cacheMode = this._urlsToCacheModes.get(url);\r\n                const request = new Request(url, {\r\n                    integrity,\r\n                    cache: cacheMode,\r\n                    credentials: 'same-origin',\r\n                });\r\n                await Promise.all(this.strategy.handleAll({\r\n                    params: { cacheKey },\r\n                    request,\r\n                    event,\r\n                }));\r\n            }\r\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                printInstallDetails(updatedURLs, notUpdatedURLs);\r\n            }\r\n            return { updatedURLs, notUpdatedURLs };\r\n        });\r\n    }\r\n    /**\r\n     * Deletes assets that are no longer present in the current precache manifest.\r\n     * Call this method from the service worker activate event.\r\n     *\r\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\r\n     * to call it yourself in your event handlers.\r\n     *\r\n     * @param {ExtendableEvent} event\r\n     * @return {Promise<workbox-precaching.CleanupResult>}\r\n     */\r\n    activate(event) {\r\n        // waitUntil returns Promise<any>\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n        return waitUntil(event, async () => {\r\n            const cache = await self.caches.open(this.strategy.cacheName);\r\n            const currentlyCachedRequests = await cache.keys();\r\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\r\n            const deletedURLs = [];\r\n            for (const request of currentlyCachedRequests) {\r\n                if (!expectedCacheKeys.has(request.url)) {\r\n                    await cache.delete(request);\r\n                    deletedURLs.push(request.url);\r\n                }\r\n            }\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                printCleanupDetails(deletedURLs);\r\n            }\r\n            return { deletedURLs };\r\n        });\r\n    }\r\n    /**\r\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\r\n     * into account the revision information for the URL.\r\n     *\r\n     * @return {Map<string, string>} A URL to cache key mapping.\r\n     */\r\n    getURLsToCacheKeys() {\r\n        return this._urlsToCacheKeys;\r\n    }\r\n    /**\r\n     * Returns a list of all the URLs that have been precached by the current\r\n     * service worker.\r\n     *\r\n     * @return {Array<string>} The precached URLs.\r\n     */\r\n    getCachedURLs() {\r\n        return [...this._urlsToCacheKeys.keys()];\r\n    }\r\n    /**\r\n     * Returns the cache key used for storing a given URL. If that URL is\r\n     * unversioned, like `/index.html', then the cache key will be the original\r\n     * URL with a search parameter appended to it.\r\n     *\r\n     * @param {string} url A URL whose cache key you want to look up.\r\n     * @return {string} The versioned URL that corresponds to a cache key\r\n     * for the original URL, or undefined if that URL isn't precached.\r\n     */\r\n    getCacheKeyForURL(url) {\r\n        const urlObject = new URL(url, location.href);\r\n        return this._urlsToCacheKeys.get(urlObject.href);\r\n    }\r\n    /**\r\n     * @param {string} url A cache key whose SRI you want to look up.\r\n     * @return {string} The subresource integrity associated with the cache key,\r\n     * or undefined if it's not set.\r\n     */\r\n    getIntegrityForCacheKey(cacheKey) {\r\n        return this._cacheKeysToIntegrities.get(cacheKey);\r\n    }\r\n    /**\r\n     * This acts as a drop-in replacement for\r\n     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\r\n     * with the following differences:\r\n     *\r\n     * - It knows what the name of the precache is, and only checks in that cache.\r\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\r\n     * and it will automatically look up the correct cache key for the currently\r\n     * active revision of that URL.\r\n     *\r\n     * E.g., `matchPrecache('index.html')` will find the correct precached\r\n     * response for the currently active service worker, even if the actual cache\r\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\r\n     *\r\n     * @param {string|Request} request The key (without revisioning parameters)\r\n     * to look up in the precache.\r\n     * @return {Promise<Response|undefined>}\r\n     */\r\n    async matchPrecache(request) {\r\n        const url = request instanceof Request ? request.url : request;\r\n        const cacheKey = this.getCacheKeyForURL(url);\r\n        if (cacheKey) {\r\n            const cache = await self.caches.open(this.strategy.cacheName);\r\n            return cache.match(cacheKey);\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Returns a function that looks up `url` in the precache (taking into\r\n     * account revision information), and returns the corresponding `Response`.\r\n     *\r\n     * @param {string} url The precached URL which will be used to lookup the\r\n     * `Response`.\r\n     * @return {workbox-routing~handlerCallback}\r\n     */\r\n    createHandlerBoundToURL(url) {\r\n        const cacheKey = this.getCacheKeyForURL(url);\r\n        if (!cacheKey) {\r\n            throw new WorkboxError('non-precached-url', { url });\r\n        }\r\n        return (options) => {\r\n            options.request = new Request(url);\r\n            options.params = Object.assign({ cacheKey }, options.params);\r\n            return this.strategy.handle(options);\r\n        };\r\n    }\r\n}\r\nexport { PrecacheController };\r\n", "/*\r\n  Copyright 2019 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { PrecacheController } from '../PrecacheController.js';\r\nimport '../_version.js';\r\nlet precacheController;\r\n/**\r\n * @return {PrecacheController}\r\n * @private\r\n */\r\nexport const getOrCreatePrecacheController = () => {\r\n    if (!precacheController) {\r\n        precacheController = new PrecacheController();\r\n    }\r\n    return precacheController;\r\n};\r\n", "/*\r\n  Copyright 2019 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\r\nimport './_version.js';\r\n/**\r\n * Helper function that calls\r\n * {@link PrecacheController#matchPrecache} on the default\r\n * {@link PrecacheController} instance.\r\n *\r\n * If you are creating your own {@link PrecacheController}, then call\r\n * {@link PrecacheController#matchPrecache} on that instance,\r\n * instead of using this function.\r\n *\r\n * @param {string|Request} request The key (without revisioning parameters)\r\n * to look up in the precache.\r\n * @return {Promise<Response|undefined>}\r\n *\r\n * @memberof workbox-precaching\r\n */\r\nfunction matchPrecache(request) {\r\n    const precacheController = getOrCreatePrecacheController();\r\n    return precacheController.matchPrecache(request);\r\n}\r\nexport { matchPrecache };\r\n", "/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { setCatchHandler } from 'workbox-routing/setCatchHandler.js';\r\nimport { matchPrecache } from 'workbox-precaching/matchPrecache.js';\r\nimport './_version.js';\r\n/**\r\n * An implementation of the [comprehensive fallbacks recipe]{@link https://developers.google.com/web/tools/workbox/guides/advanced-recipes#comprehensive_fallbacks}. Be sure to include the fallbacks in your precache injection\r\n *\r\n * @memberof workbox-recipes\r\n *\r\n * @param {Object} [options]\r\n * @param {string} [options.pageFallback] Precache name to match for pag fallbacks. Defaults to offline.html\r\n * @param {string} [options.imageFallback] Precache name to match for image fallbacks.\r\n * @param {string} [options.fontFallback] Precache name to match for font fallbacks.\r\n */\r\nfunction offlineFallback(options = {}) {\r\n    const pageFallback = options.pageFallback || 'offline.html';\r\n    const imageFallback = options.imageFallback || false;\r\n    const fontFallback = options.fontFallback || false;\r\n    self.addEventListener('install', (event) => {\r\n        const files = [pageFallback];\r\n        if (imageFallback) {\r\n            files.push(imageFallback);\r\n        }\r\n        if (fontFallback) {\r\n            files.push(fontFallback);\r\n        }\r\n        event.waitUntil(self.caches\r\n            .open('workbox-offline-fallbacks')\r\n            .then((cache) => cache.addAll(files)));\r\n    });\r\n    const handler = async (options) => {\r\n        const dest = options.request.destination;\r\n        const cache = await self.caches.open('workbox-offline-fallbacks');\r\n        if (dest === 'document') {\r\n            const match = (await matchPrecache(pageFallback)) ||\r\n                (await cache.match(pageFallback));\r\n            return match || Response.error();\r\n        }\r\n        if (dest === 'image' && imageFallback !== false) {\r\n            const match = (await matchPrecache(imageFallback)) ||\r\n                (await cache.match(imageFallback));\r\n            return match || Response.error();\r\n        }\r\n        if (dest === 'font' && fontFallback !== false) {\r\n            const match = (await matchPrecache(fontFallback)) ||\r\n                (await cache.match(fontFallback));\r\n            return match || Response.error();\r\n        }\r\n        return Response.error();\r\n    };\r\n    setCatchHandler(handler);\r\n}\r\nexport { offlineFallback };\r\n"],
  "mappings": "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",
  "names": ["precacheController", "precacheController", "options"]
}
